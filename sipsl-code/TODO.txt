ISSUES

5 agosto 

indirizzi numerici o a stringa
se grog$=127.0.0.1
oppure $grog=grog.sipsl.org

PD-SIPSL
i%127.0.0.1:5062%service@127.0.0.1:5062
send
oppure
PD-SIPSL
i%127.0.0.1:5062%service@grog.sipsl.org:5062
send



4 agosto

sendReply e sendRequest
ma la host a che serve???
che succede se uso indirizzi non numerici????


2 agosto

overload protection


Luglio 30

OM-SIPSL
dump comap

scarica nel log tutti gli oggetti ancora aperti e il loro overall state

http://download.oracle.com/docs/cd/E18752_01/html/816-5137/ggfbr.html

umft2
PD-SIPSL
i%10.21.99.81:5062%service@10.21.99.81:5062
send
umft1
PD-SIPSL
i%10.21.99.79:5062%service@10.21.99.79:5062
send

suse
PD-SIPSL
i%127.0.0.1:5062%service@127.0.0.1:5062
send


umf1 - mas set
export mas=10.21.99.67
export umf=10.21.99.79

umf2 - mas set
export mas=10.21.99.67
export umf=10.21.99.81


28 luglio 
dividere la doa in + trheads

27 luglio

leak nella message
dovrebbe essere la PURGEMESSAGE che non toglie il record dalla module map


22 luglio

i controlli nella comap non funzionano...
Assertion failed: 0, file c/TRNSCT_SM.cpp, line 310
zsh: 16361 IOT instruction (core dumped)  ./SI |
zsh: 16362 done                           tee log > /dev/null


il collo sta tra due engines 
se il chiamante ha molti threads rallenta un sacco...




20 luglio
bool ENGINE::p_w_v2(void* _m) {

	//put message in queue (already th safe)
	//return
}
// p_w_v2
// if there is a message
// take message execute parse

togliere il mutex nello spin, non serve
comunque non dovrebbe influre molto

per ogni thread calcolare il tempo di sleep
= tot - attesa nei lock - tempo mimino di computazione
il tempo di sleep indica che il th non ha cpu disponibile
potrebbe spiegare perche se aumento i threads i tempi salgono

provare pthread_getcpuclockid

rifare modulo messaggio usare una soluzione ibrida tra funzione e mappe
vedere prova.exe si calcola un modulo basso (10) e poi si cerca
in una delle 10 mappe

i controlli nella comap non funzionano...
Assertion failed: 0, file c/TRNSCT_SM.cpp, line 310
zsh: 16361 IOT instruction (core dumped)  ./SI |
zsh: 16362 done                           tee log > /dev/null

----------------

13 luglio

issue:
se arriva il BYE A no sempre parte il 200ok
perche OVERALLstate e' diverso



TODO

1. ottimizzare le getXXX dopo la compile message

- perche su UMF una chiamata usa meno messaggi???

- spezzare SL_CO lato client e server son due lock separati
ancora in test, fare gli scenari di errore

- implementare il controllo  di carico e i messaggi di reject
lato client 

- timer sul temporary state nella comap se gli allarmi sono inibiti
oppure riabilitare gli allarmi ma solo per le timer_s
con un counter dipendente dal timer doa

SUPERCARICO
- in caso di super carico il bye non va quasi piu
- il core avviene durante la downcall forse le funzioni unix


2. perche quando un solo messaggio va in ritrasmissione scoppia il casino???
3. base dati stl
4. SIP messaggi di errore/overload
4. come definire overload in SIPSL
5.





















Finire ritrasmissioni e deletion logic
fatta la INV_SV
test


************************************************************************************
La global message table Ã¨ unica. E' possible usarne di piu?
Controllare se impedisce la concorrenza.

************************************************************************************
Misure


************************************************************************************
Performance
- aprire piu socket 


